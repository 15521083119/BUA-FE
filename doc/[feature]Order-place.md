

# 提交订单

## 需求分析

### 提交订单时需要做如下事情：

- 生成订单数据
- 减库存
- 核销优惠券

### 订单状态

待支付 -> 取消 

- 手动取消
- 超时取消，（为什么要使用延迟消息队列？）

### 减库存的时机

两种思路：支付成功后 以及 下单成功后

主要区别在于并发竟态场景下有所区别。

#### 支付成功后

实现较为简单，因为不涉及取消订单时的库存归还，但是容易出现超卖现象。产生超卖现象的例子：

商品A：库存量100件

A用户生成订单：准备购买60件商品

B用户生成订单：准备购买60件商品

当A和B同时下单时，会出现**负库存现象**，虽然可以在支付前一刻进行库存判断防止情况发生，但这样会降低用户体验。

> 用户B：什么鬼，老子订单都提交了，交钱时候告诉我库存不够了！！

#### 下单过程中

可以在下单时对库存进行预减，用户下单是进行一个连续的事务操作，生成订单后会立即进行商品的库存扣减。如果在商品扣减时候发现此次操作会导致负库存现象，则直接抛出异常，提示用户。

但需要考虑两个问题：

1. 如何在用户取消订单时进行库存归还？
2. 如何保证并发竟态场景下扣减库存时的准确性不出现负库存？

对于1放在后面延迟消息队列进行叙述，先看问题2.

对于第二个问题我们可以使用乐观锁思想，加锁的目的在于**保证共享的资源在并发竞态的时候有序访问**。乐观锁的意思是说，采用乐观心态，在每次扣减库存时认为只有我一个人在操作，不会有其他人插手。但乐观归乐观，还是需要判断一下是否可以减库存。如果不可以减库存直接抛出异常。（和严格意义上的乐观锁有出入）

> 解释一下，在库存扣减时，是对数据库进行数据写操作需要十分谨慎，不能认为前面的校验器校验过就是是安全的，主要还是因为高并发场景下存在竟态。前面检测是有意义的，能够及时反馈用户，但不能作为用户下单的唯一依据起决定性。

补充：也可以在代码层面加锁一个事务中只能有一个线程去操作：先查询数据库，判断后再减数据库。但存在nodejs集群的分布式架构下无效，或者说难处理的问题。

### 核销优惠券 （状态更改）

同上问题，生成订单前的检查并不能唯一依据，因为是对数据库进行写操作，需要较为严谨，在写数据库前需要再次对优惠券进行逻辑判断，防止一个用户一张优惠券多次使用。

## RD

## extra

### 订单号和流水号有什么区别？

### 数据库什么时候需要加上事务？

### 什么是悲观锁和乐观锁？

连续的新增或者更新



没有事务会怎么样？ 



连续 写入更新操作必须加上事务，防止出现宕机后”断片“，这样就会保证事务失败能够进行回滚。